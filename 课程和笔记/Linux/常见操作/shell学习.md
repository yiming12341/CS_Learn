# shell学习

## 基础知识

我们可以在`/etc/shells`这个目录中查看我们操作系统中所拥有的shell.

也可以使用下面的命令查找出我们正在使用的shell

```shell
echo $SHELL
```

我们可以直接输入`shell`的名字来对shell进行改变。但是如果需要永久性的改变shell，需要将自己想要使用的shell设置为默认的shell.

```shell
which shell_name 					#用于获取shell的路径
chsh -s shell_path	[userid]		#设置用户为userid为默认的shell，shell_path是上一条命令获得的路径
```



## shell变量

- 分类：
  - 环境变量：也称全局变量，通常使用大写字母来表示
    - 使用`env`或者`printenv`可以查看
  - shell变量：在shell环境中创建变量
    - 可以通过`set`查看

### 显示使用变量的值

#### echo

echo的任务就是显示赋予它的任何对象的值，如果需要显示变量需要使用`${}`来显示，可以一次显示多个变量。

```bash
echo dollar					#显示dollar
echo $dollar				#显示dollar变量的值
```

注意在shell中有很多特殊的符号显示其他意义，比如`<`,`>`就是显示重定向的。这个时候如果我们不对这些符号进行处理，那么就会导致shell按照这些符号的功能来执行任务，如果只是想让它显示这些符号，那么需要用`""`来避免shell对其解释。

```shell
echo <$HOME>
echo "<$HOME>"
```

#### 使用变量

定义变量，并使用export导出

```bash
export PAGER=less EDITOR=vi PATH="/usr/local/bin/:/usr/bin:/bin"
```

### shell选项

shell选项是控制shell的一些功能的设置，我们可以使用`set -o`或者`set +o`来查看选项并设置选项。

具体如下：

```shell
set -o option				#设置一个选项
set +o option				#关闭一个选项
set -o
set +o						#查看选项
```

### 元字符

元字符是在Linux shell中使用的一些特殊字符，它们具有特殊的含义和作用。

#### 常见的元字符

| 元字符 | 作用                                               |
| ------ | -------------------------------------------------- |
| `;`    | 分隔符，用于将多个命令放在同一行中                 |
| `&`    | 后台执行符，将命令放在后台执行                     |
| `      | 命令替换                                           |
| `>`    | 重定向符，将命令的输出重定向到文件中               |
| `>>`   | 追加重定向符，将命令的输出追加到文件中             |
| `<`    | 输入重定向符，将文件作为命令的输入                 |
| `*`    | 通配符，匹配任意数量的字符                         |
| `?`    | 通配符，匹配任意一个字符                           |
| `[ ]`  | 通配符，匹配指定范围内的字符                       |
| `{ }`  | 大括号扩展符，用于扩展多个字符串                   |
| `\`    | 转义符，下一个字符转义                             |
| `#`    | 注释符，用于注释一行命令                           |
| `()`   | 圆括号，用于创建子shell或在当前shell中执行命令列表 |
| `|`    | 管道                                               |
| `''`   | 取消全部的替换                                     |
| `""`   | 取消大部分替换                                     |

#### 转义

如果想要元字符不显示他的作用，就需要使用转义来实现。常见的转义主要用下面三种方式：

- `\`:只转义单个字符
- `''`：在`''`中的内容全部不使用元字符的意义
- `""`：只有`$,反引号，\`这三个有元字符的意义

> 注意\甚至能转义<enter>键，因此如果命令太长，我们可以在命令的最后一句，添加\，然后就按下enter就可以接着在下一行书写

### 使用变量的值

使用`$变量名`来使用,常见的变量有

| 变量       | 作用                                   |
| ---------- | -------------------------------------- |
| `$HOME`    | 当前用户的家目录                       |
| `$PATH`    | 环境变量，用于指定可执行文件的搜索路径 |
| `$USER`    | 当前用户的用户名                       |
| `$UID`     | 当前用户的用户ID                       |
| `$GROUPS`  | 当前用户所在的用户组                   |
| `$PWD`     | 当前工作目录                           |
| `$SHELL`   | 当前使用的shell                        |
| `$PS1`     | shell提示符                            |
| `$PS2`     | shell二级提示符                        |
| `$IFS`     | shell输入字段分隔符                    |
| `$TERM`    | 当前终端类型                           |
| `$DISPLAY` | X Window系统的显示器                   |

使用转义字符的特殊码来使用

## 命令替换

命令替换允许在一条命令中嵌入另外一条命令。在Linux中，命令替换是一种非常有用的技术，它可以将一个命令的输出作为另一个命令的输入。命令替换可以使用反引号（`）或$（）来完成。

反引号`方法：

```bash
command1 `command2`
```

其中，command2是一个命令，它的输出将作为command1的参数。例如，使用date命令来获取当前时间，并将其作为mkdir命令的参数来创建一个以当前时间为名称的目录：

```bash
mkdir `date +%Y%m%d%H%M%S`
```

在执行此命令时，将使用date命令的输出作为mkdir命令的参数，创建一个以当前时间为名称的目录。

$()方法：

```bash
command1 $(command2)
```

其中，command2是一个命令，它的输出将作为command1的参数。例如，使用ls命令来列出当前目录下的所有文件，并使用wc命令来统计文件的数量：

```
echo "There are $(ls | wc -l) files in the current directory."
```

在执行此命令时，将使用ls命令的输出作为wc命令的输入，统计文件的数量，并将其作为echo命令的参数打印出来。

命令替换的使用可以帮助我们更加高效地处理数据和执行命令，特别是在编写shell脚本时，命令替换是非常有用的技术。需要注意的是，在使用命令替换时，需要注意命令的输出格式和内容，以确保它们可以正确地作为另一个命令的参数使用。

## 使用小技巧

### 历史命令

使用`history`命令查看使用了的历史命令，如果想执行历史命令，使用`!历史命令的编号`来执行历史命令，但是推荐使用fish这个shell，可以自动搜索历史命令。使用上下箭头，相当于在本条命令的基础上，向上向下查阅历史命令。

### 自动补全

使用tab键可以自动补全命令

### 别名

可以为某些命令设置别名，然后就能减少命令输入的长度，就能较为方便的使用命令。

语法：

```shell
alias name="command"
```

当然可以别名以执行多条命令，例如

```shell
alias info='date;who'
```

使用unalias来移除别名

```shell
unalias name
```

### 条件执行

执行完一条命令，没有出错的情况下，再去执行另一条

```shell
command1 && command2
```

执行完第一条之后无论成不成功都执行第二条

```sh
command1 || command2
```



# 数据流重定向

## 文件描述符

在Unix中每一个输入源和输出源都由一个唯一的数字唯一标识。这个数字便称为文件描述符。文件描述符是一个非负的数字，我们通常使用0,1,2来分别对应标准输入、标准输出和标准错误。在shell中重定向的语法的本质实质上是在文件描述符数字之后使用`<`或者`>`来实现的。

例如：

```bash
sort 1> output.txt
sort > output.txt
```

这两个命令实质上是一样的，都是把标准输出重定向到了output.txt文件中。

再例如：

```bash
sort 0< input.txt 1> out.txt 2>errors.txt
```

这条语句的含义是将文件input.txt中的内容进行排序，并将排序后的结果输出到out.txt文件中，同时将错误信息输出到errors.txt文件中。下面是该命令的执行过程及原理：

1. 首先，shell会将sort命令和重定向符号解析成一个命令行管道。sort命令将从标准输入中读取数据，并将排序后的结果输出到标准输出中。
2. 重定向符号“0<”表示将标准输入重定向到一个名为“input.txt”的文件中。因此，sort命令将从“input.txt”文件中读取数据进行排序。
3. 重定向符号“1>”表示将标准输出重定向到一个名为“out.txt”的文件中。因此，sort命令将排序后的结果输出到“out.txt”文件中。
4. 重定向符号“2>”表示将标准错误输出重定向到一个名为“errors.txt”的文件中。如果sort命令在执行过程中发生错误，错误信息将被输出到“errors.txt”文件中。

因此，执行该命令的过程如下：

1. sort命令从“input.txt”文件中读取数据，并将数据进行排序。
2. 排序后的结果将被输出到“out.txt”文件中。
3. 如果在排序过程中发生错误，错误信息将被输出到“errors.txt”文件中。

总之，使用重定向符号可以将命令的输入和输出重定向到其他文件中，从而实现对命令执行过程的控制。在这个例子中，重定向符号“0<”、“1>”和“2>”分别将标准输入、标准输出和标准错误输出重定向到不同的文件中，从而实现了对sort命令的输入和输出的控制。

## 标准输入输出

在Linux中，标准输入、标准输出和标准错误是三个重要的文件描述符，分别对应着0、1和2。它们的作用如下：

1. 标准输入（stdin）：它是程序默认的输入设备，通常是键盘或者其他的输入设备。当程序需要从用户那里获取输入时，就会从标准输入读取数据。
2. 标准输出（stdout）：它是程序默认的输出设备，通常是屏幕或者其他输出设备。当程序需要输出信息时，就会将信息输出到标准输出中。
3. 标准错误（stderr）：它通常用来输出程序的错误信息，与标准输出不同的是，标准错误的输出不会被重定向到其他文件中。

这种设计的好处在于：

1. 方便程序的输入输出：程序可以通过标准输入和标准输出来与用户进行交互，使得程序的输入输出更加方便。
2. 方便程序的重定向：标准输入、标准输出和标准错误可以被重定向到其他文件中，这样可以方便地记录程序的输入输出以及错误信息。
3. 方便程序的管道操作：标准输入、标准输出和标准错误可以通过管道进行连接，使得程序之间的数据传输更加方便和高效。

## 重定向

当打开shell的时候，shell会默认标准输入为键盘，标准输出和标准错误是屏幕，因此大多数程序都是以键盘作为输入，以屏幕作为输出，这样能很方便的进行人机交互。

但是我们可以通过重定向的方式，来更改标准输入和输出以及错误。重定向的本质在于将原本默认的输入输出，更改为其他的文件（**Linux中一切皆文件，屏幕和键盘也只是一种文件罢了**）。

下面是三种方式的重定向方式：

- 标准输出：
  - `>`
  - `>>`
- 标准输入
  - `<`
- 标准错误：
  - 使用`2>`

一些常用符号的总结：

| 元字符   | 动作                               |
| -------- | ---------------------------------- |
| <        |                                    |
| >        |                                    |
| >\|      | 重定向标准输出强制重写             |
| >>       |                                    |
| 2>       | 重定向标准错误                     |
| 2>>      |                                    |
| 2&>1     | 将标准错误重定向到标准输出         |
| >&或者&> | 重定向标准输出+标准错误            |
| \|       | 将标准输出通过管道传递到宁一条命令 |



# 管道

## 基本语法

### 概念

shell中使用`|`来连接两个不同程序的标准输入和输出，`|`将左边的标准输出连接到了右边的标准输入。

例如：

```bash
command1 2&>1 | command2
```

就是把标准输出和错误，连接到一起传输给第二个命令。

### tee数据保存

当我们使用管道的时候，如果我们想要将数据保存到一个文件当中，我们可以借助tee命令来帮助我们实现这个功能，其语法为：

```shell
tee filename...
```

具体使用案例为：

```shell
cat name[123] | tee date | grep Hello
```

# 过滤器

过滤器就是能从标准输入读取数据然后输出到标准输出的这一类程序。常用的过滤器如下

| 过滤器名字 | 概述                                                         |
| ---------- | ------------------------------------------------------------ |
| grep       | 从文件或标准输入中搜索文本模式，并将匹配的行打印到标准输出   |
| awk        | 用于处理文本文件的工具，可以对文件进行逐行处理，对每一行进行分析处理，然后输出 |
| sed        | 流编辑器，用于对文本文件进行替换、删除、插入等操作           |
| sort       | 对文本文件进行排序                                           |
| uniq       | 用于从已排序的文本文件中删除重复行                           |
| cut        | 从文本文件中提取指定的字段                                   |
| tr         | 用于转换或删除文本文件中的字符                               |
| wc         | 统计文本文件的行数、单词数、字符数                           |
| head       | 打印文本文件的前几行                                         |
| tail       | 打印文本文件的后几行                                         |
| tee        | 从标准输入读取数据，并同时将数据输出到标准输出和一个或多个文件 |
| comm       | 比较两个已排序的文件，并输出它们的共有行、不同行和只在一个文件中出现的行 |
| join       | 将两个已排序的文件按照共有字段进行连接                       |
| paste      | 将多个文件的相同行合并为一行                                 |

## 文本查看

### cat

将标准输入显示到标准输出。输入的结束符为`eof(ctrl+D)`。

常用的形式为：

```bash
cat > file				#将标准输入，输出到文件
cat < file				#将文件内容显示到屏幕
cat file...				#将多个文件内容合并，显示到屏幕，就是第二条命令的变种，这条命令很有用，提供了数据的连接
cat <file1 >file2		#复制文件
cat file1 file2 file2 | command 	#用于数据的合并
```

常见参数:

- `-n`:写出行号
- `-b`：不对空白行编号
- `-s`：将多个空白行压缩为1个

### split

拆解文件

```shell
split -l num file-name
```

按照num行将文件拆解。

### tac

将行反转

```bash
tac file...
```

### rev

每行字符反转

```sh
rev file...
```

### head

显示前num行

```bash
head -n num
```

### tail

显示最后num行

```shell
tail -n num
```

## 比较和抽取

### grep

抽选出含有特定模式的行，并写到标准输出。支持正则表达式。

```sh
grep [-cilLnrsvwx] pattern [file...]
```

从file中抽取匹配或者包含pattern的行。

参数选项：

- `-i`:忽略大小写
- `-n`:显示抽取之前的行号
- `-w`：只希望搜索完整的单词
- `-v`: 去补集输出
- `-c`:查看数量
- `-r`:递归搜寻目录下的所有文件

### look

查询以某模式开头的行

```
look [-df] pattern file...
```



### cmp

比较任意两个文件，但是只会显示有多少不同

```sh
cmp file1 file2
```

### diff

使用`diff -c file1 file2`命令来比较两个文件之间的区别。

### cut

从文件中挑选出一些行来。例如

```sh
cut -c 10-20,23-38 file
```

抽选字段

```sh
cut -f 列号 -d '分界符' 文件
```



### paste

合并

```sh
paste -d "分隔符" file...
```



## 统计

### nl

添加行号

```sh
nl [-v start] [-i increment] file...
```

其中start为开始数字，increment为增量

### wc

wc用于统计多个文件的行，单词，字符数

输出格式为：`行数 单词数 字符数 文件名`

语法：

```sh
wc [-clLw] file...
```

其中`-c`统计字符，`-l`统计行，`-w`统计字符，`-L`显示输入中最长行的长度，不写参数默认前三个。

### fold

处理长的行，让其变得规整

```sh
fold -w num filename
```

num为行的长度。

## 排序组合和变换

### sort

sort的参数

- `-d`：只查看数字，字母或者空白符
- `-f`：选择同等对待对待大写字母和小写字母
- `-n`：识别数字，并按照数字排序
- `-r`：反向

### sed

一个替换功能

```sh
sed -i 替换串 file
```

其中替换串应该满足下面的语法：

`[num]s/原来的串/替换成的串/[g]`如果不带g，那么只替换第一个，如果带了那就全部替换，如果带了num那么就是只在第几行替换。

替换多个，每个之前都需要用`-e`参数

```sh
sed -i \
-e 's/mon/Monday/g' \
-e '4s/tue/Tuesday/g' \
file
```

